window._component = {
    trash: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
  <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
  <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
</svg>`,
    move: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
  <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
</svg>`,
    write: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
  <path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"/>
  <path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5v11z"/>
</svg>`,
    close: `<svg style="vertical-align: middle;" width="16" height="16" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill="none" stroke="white" stroke-width="2.5" d="M16,16 L4,4"></path><path fill="none" stroke="white" stroke-width="2.5" d="M16,4 L4,16"></path></svg>`,
    aspect: `<svg xmlns="http://www.w3.org/2000/svg" style="vertical-align: middle;" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
  <path fill="#ffffff" d="M0 12.5v-9A1.5 1.5 0 0 1 1.5 2h13A1.5 1.5 0 0 1 16 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 12.5zM2.5 4a.5.5 0 0 0-.5.5v3a.5.5 0 0 0 1 0V5h2.5a.5.5 0 0 0 0-1h-3zm11 8a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 0-1 0V11h-2.5a.5.5 0 0 0 0 1h3z"/>
</svg>`,
    check: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
  <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/>
</svg>`,
    check_circle: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
  <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
  <path d="M10.97 4.97a.235.235 0 0 0-.02.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-1.071-1.05z"/>
</svg>`,
    caret_right: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
  <path d="m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z"/>
</svg>`,
    caret_right_circle: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
  <path d="M6 12.796V3.204L11.481 8 6 12.796zm.659.753 5.48-4.796a1 1 0 0 0 0-1.506L6.66 2.451C6.011 1.885 5 2.345 5 3.204v9.592a1 1 0 0 0 1.659.753z"/>
</svg>`,
    sub_loading: `<svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 50 50" style="background: rgb(223 9 127);border-radius: 50%;" xml:space="preserve">
  <path fill="#ffffff" stroke="#ffffff" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z">
    <animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform>
    </path>
  </svg>`,
    node: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-diagram-3-fill" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M6 3.5A1.5 1.5 0 0 1 7.5 2h1A1.5 1.5 0 0 1 10 3.5v1A1.5 1.5 0 0 1 8.5 6v1H14a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0V8h-5v.5a.5.5 0 0 1-1 0V8h-5v.5a.5.5 0 0 1-1 0v-1A.5.5 0 0 1 2 7h5.5V6A1.5 1.5 0 0 1 6 4.5v-1zm-6 8A1.5 1.5 0 0 1 1.5 10h1A1.5 1.5 0 0 1 4 11.5v1A1.5 1.5 0 0 1 2.5 14h-1A1.5 1.5 0 0 1 0 12.5v-1zm6 0A1.5 1.5 0 0 1 7.5 10h1a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 8.5 14h-1A1.5 1.5 0 0 1 6 12.5v-1zm6 0a1.5 1.5 0 0 1 1.5-1.5h1a1.5 1.5 0 0 1 1.5 1.5v1a1.5 1.5 0 0 1-1.5 1.5h-1a1.5 1.5 0 0 1-1.5-1.5v-1z"/>
</svg>`,
    request: function (settings) {
        settings = Object.assign({
            url: '',
            method: "GET",
            header: {},
            data: {},
            callback: null,
            error_callback: null,
            timeout:30000
        }, settings);
        let xhr = new XMLHttpRequest();
        if (settings.method === 'GET') settings.url = _component.parseParams(settings.url, settings.data);
        xhr.open(settings.method, settings.url, true);
        xhr.timeout = settings.timeout;
        let token = '';
        if (document.querySelector('meta[name="csrf-token"]')) {
            token = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
        }
        xhr.setRequestHeader("X-CSRF-TOKEN", token);
        if (settings.header) {
            for (let header in settings.header) {
                if (!settings.header.hasOwnProperty(header)) continue;
                xhr.setRequestHeader(header, settings.header[header]);
            }
        }
        if (settings.method === 'GET') {
            xhr.setRequestHeader("Content-type", "application/text;charset=UTF-8");
            xhr.responseType = "text";
            xhr.send(null);
        } else {
            if(settings.data instanceof FormData) {
                xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            }else {
                xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
                settings.data = JSON.stringify(settings.data);
            }
            xhr.responseType = "json";
            xhr.send(settings.data);
        }
        xhr.onload = function () {
            if (this.status >= 200 && this.status < 300) return;
            if (typeof settings.error_callback === 'function') settings.error_callback();
        };
        xhr.onreadystatechange = function () {
            if (xhr.readyState === xhr.DONE && xhr.status === 200) {
                let response = xhr.response;
                if (typeof settings.callback === 'function') settings.callback(response);
            }
        };
        xhr.onerror = function (e) {
            console.error(e);
            if (typeof settings.error_callback === 'function') settings.error_callback(e);
        };
    },
    parseParams(uri, params) {
        let paramsArray = [];
        if (Object.keys(params).length === 0) return uri;
        Object.keys(params).forEach(key => params[key] && paramsArray.push(`${key}=${params[key]}`));
        if (uri.search(/\?/) === -1) {
            uri += `?${paramsArray.join('&')}`
        } else {
            uri += `&${paramsArray.join('&')}`
        }
        return uri
    },
    loading: function (DOM, remove = false) {
        if (remove) {
            DOM.innerHTML = '';
            return;
        }
        DOM.insertAdjacentHTML('afterbegin', `<div class="dlp-loader">
        <div class="dlp-loader-inner">
            <div class="dlp-loader-line-wrap"><div class="dlp-loader-line"></div></div>
            <div class="dlp-loader-line-wrap"><div class="dlp-loader-line"></div></div>
            <div class="dlp-loader-line-wrap"><div class="dlp-loader-line"></div></div>
            <div class="dlp-loader-line-wrap"><div class="dlp-loader-line"></div></div>
            <div class="dlp-loader-line-wrap"><div class="dlp-loader-line"></div></div>
        </div></div>`);
    },
    _alert_documents:[],
    alert: function (message, time = 1, callback = null, dom = null) {
        let div = document.createElement('div');
        div.insertAdjacentHTML('afterbegin',`<span class="dlp dlp-text">${message}</span>`);
        let w, h;
        div.className = 'dlp-alert';
        this._alert_documents.forEach((D)=>{
            D.style.top = parseInt(D.style.top) - 60 + 'px';
        });
        this._alert_documents.push(div);
        if (!dom) {
            document.getElementsByTagName("BODY")[0].appendChild(div);
        } else {
            dom.append(div);
        }
        if (!dom) {
            w = (window.innerWidth - 320) / 2;
            h = window.innerHeight / 2 - 15;
            div.style.position = 'fixed';
        } else {
            w = (dom.offsetWidth - 320) / 2;
            h = dom.offsetHeight / 2 - 15;
            div.style.position = 'absolute';
        }
        div.style.top = h + 'px';
        div.style.left = w + 'px';
        setTimeout(() => {
            let dom = this._alert_documents.shift();
            dom.parentNode.removeChild(dom);
            if (typeof callback === 'function') callback();
        }, time * 1000);
    },
    dialog:function(info,width,height){
        let gauze = document.createElement('div');
        gauze.className = 'dlp-plane-gauze';
        let box = document.createElement('div');
        if (width) {
            box.style.width = width;
        }else {
            box.style.width = '450px';
        }
        let top;
        if(height){
            top = (window.innerHeight - height - 24) / 2;
        }else {
            top = (window.innerHeight - 94) / 2;
        }
        box.style.margin = `${top}px auto`;
        let header = document.createElement('div');
        header.className = 'dlp plane-header';
        /*X*/
        let X = document.createElement('i');
        X.insertAdjacentHTML('afterbegin', _component.close);
        X.addEventListener('click', () => {
            if (this.DOM instanceof HTMLElement) {
                this.DOM.remove();
            }
            if (document.getElementById('kvFileinputModal') instanceof HTMLElement) {
                document.getElementById('kvFileinputModal').remove();
            }
        }, false);
        header.append(X);
        let body = document.createElement('div');
        body.className = 'plane-body';
        if(height){
            body.style.height = height;
        }else {
            body.style.height = '70px';
        }
        if (info instanceof HTMLElement){
            body.append(info);
        }else {
            body.insertAdjacentHTML("afterbegin", info);
        }

        box.append(header);
        box.append(body);
        gauze.append(box);
        this.DOM = gauze;
        document.body.append(gauze);
        return body;
    },
    contextmenu: function (event, list, options = {}) {
        options = Object.assign({
            W: '70px'
        }, options);
        let ul = document.createElement('ul');
        ul.className = 'dlp dlp-contextmenu';
        list.forEach((v) => {
            let li = document.createElement('li');
            li.className = 'dlp dlp-text';
            li.insertAdjacentHTML('afterbegin', v.title);
            li.style.width = options.W;
            if (typeof v.func === 'function') {
                li.addEventListener('click', () => {
                    ul.remove();
                    setTimeout(() => {
                        v.func();
                    }, 100);
                });
                ul.append(li);
            }
        });
        ul.style.top = `${event.pageY - 3}px`;
        ul.style.left = `${event.pageX - 3}px`;
        ul.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });
        ul.addEventListener('mouseleave', () => {
            ul.remove();
        });
        document.getElementsByTagName("BODY")[0].appendChild(ul);
    },
    dimensional(output, data, dimension = 0, parentNodes = []) {
        if (Array.isArray(data)) {
            for (let k in data) {
                if (!data.hasOwnProperty(k)) continue;
                let parents = parentNodes.slice(0);
                parents.push(data[k].key);
                _component.dimensional(output, data[k], dimension, parents);
            }
            return;
        }
        let parents = parentNodes.slice(0);
        parents.pop();
        data.parentNodes = parents;
        if (!Array.isArray(output[dimension])) {
            output[dimension] = [data];
        } else {
            output[dimension].push(data);
        }
        if (!data.hasOwnProperty('nodes') || !Array.isArray(data.nodes) || data.nodes.length === 0) {
            return;
        }
        dimension++;
        _component.dimensional(output, data.nodes, dimension, parentNodes);
    },
    imgDelay(name,time=200,zoom= false,width=300,height = 0) {
        let list = document.getElementsByClassName(name);
        let i = 0;
        for(let dom of list){
            setTimeout(()=>{
                let src = dom.getAttribute('data-src');
                dom.setAttribute('src',src);
                dom.onload = function(){
                    if(!zoom)return;
                    let img = document.createElement('img');
                    dom.addEventListener('mouseover', function(e) {
                        document.body.append(img);
                        img.style.position = 'absolute';
                        img.style.zIndex = '1000000';
                        img.style.borderRadius = '3px';
                        img.setAttribute('src', src);

                        let scale;
                        if(width === 0){
                            scale = img.naturalWidth / img.naturalWidth;
                        }else {
                            scale = width / img.naturalWidth;
                        }
                        let offsetY = img.naturalHeight * scale / 2;
                        if(height>0){
                            offsetY = height / 2;
                            img.style.height = `${height}px`;
                        }else if (height<0) {
                            if (img.naturalHeight > window.innerHeight){
                                let h = (window.innerHeight - 10);
                                img.style.height = `${h}px`;
                                offsetY = (h) / 2;
                                width = 0;
                            }
                        }
                        if(width>0) {
                            img.style.width = `${width}px`;
                        }else {
                            img.style.width = `auto`;
                        }
                        img.style.top = `${e.pageY - offsetY}px`;
                        let distanceToBottom = window.innerHeight - e.clientY;
                        if (window.innerHeight - e.clientY < offsetY + 5){
                            img.style.top = `${e.pageY - (offsetY + (offsetY - distanceToBottom) + 5)}px`;
                        }else if(e.clientY < offsetY - 5){
                            img.style.top = `${e.pageY - (offsetY - (offsetY - e.clientY) - 5)}px`;
                        }
                        if(window.innerWidth - e.clientX < img.naturalWidth){
                            img.style.left = `${e.pageX - img.naturalWidth - 30}px`;
                        }else {
                            img.style.left = `${e.pageX + 25}px`;
                        }
                    });
                    dom.addEventListener('mouseout', function(e) {
                        e.stopPropagation();
                        img.remove();
                    });
                };
            },i*time);
            i++;
        }
    }
};

window.ComponentDot = class {
    MODE = {
        insert: 'insert',
        delete: 'delete'
    };

    constructor(name, select, selected, limit = 0) {
        if (!Array.isArray(selected)) {
            console.error('Dot param selected must be array!');
            return;
        }
        if (Array.isArray(select) || typeof select !== 'object') {
            console.error('Dot param select must be object such as {key:val,key2:val2,...} !');
            return;
        }
        this.select = select;
        this.name = name;
        this.limit = limit;
        this.DOM = document.getElementById(name);
        this.DOM.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });

        selected = selected.filter(d=>{
            if(select[d] === undefined)return false;
            return true;
        });
        this.selected_data = selected;
        this.select_data = [];
        this.insert_data = [];
        this.delete_data = [];
        this._modSettings = {mode: false};
        this._useSearchMod = false;
        this._triggerEvent = null;

        this._tagSelect = function(element) {
            if (this.limit > 0 && this.select_data.length >= this.limit && this.SELECTED_DOM.firstChild instanceof HTMLElement) {
                this.SELECTED_DOM.firstChild.click();
            }
            let clone = element.cloneNode(true);
            clone.addEventListener('click', ()=>this._tagCancel(clone), false);
            this.SELECTED_DOM.appendChild(clone);
            element.remove();
            this._tagCal(parseInt(element.getAttribute('data-id')), this.MODE.insert);
            this.SELECTED_DOM.scrollTop = this.SELECTED_DOM.scrollHeight;
        };

        this._tagCancel = function(element) {
            let clone = element.cloneNode(true);
            clone.addEventListener('click', ()=>this._tagSelect(clone), false);
            this.CONTENT_DOM.appendChild(clone);
            element.remove();
            this._tagCal(parseInt(element.getAttribute('data-id')), this.MODE.delete);
        };

        this._tagCal = function(id, operate) {
            let index = this.select_data.indexOf(id);
            if (operate === this.MODE.insert) {
                if (index === -1) {
                    this.select_data.push(id);
                    this.selectInputDOM.value = JSON.stringify(this.select_data);
                }
                if (this.selected_data.indexOf(id) === -1 && this.insert_data.indexOf(id) === -1) {
                    this.insert_data.push(id);
                    this.insertInputDOM.value = JSON.stringify(this.insert_data);
                }
                index = this.delete_data.indexOf(id);
                if (index !== -1) {
                    this.delete_data.splice(index, 1);
                    this.deleteInputDOM.value = JSON.stringify(this.delete_data);
                }
            } else {
                if (index !== -1) {
                    this.select_data.splice(index, 1);
                    this.selectInputDOM.value = JSON.stringify(this.select_data);
                }
                if (this.selected_data.indexOf(id) !== -1 && this.delete_data.indexOf(id) === -1) {
                    this.delete_data.push(id);
                    this.deleteInputDOM.value = JSON.stringify(this.delete_data);
                }
                index = this.insert_data.indexOf(id);
                if (index !== -1) {
                    this.insert_data.splice(index, 1);
                    this.insertInputDOM.value = JSON.stringify(this.insert_data);
                }
            }
            if (typeof this._triggerEvent == 'function'){
                this._triggerEvent(this.select_data,this.insert_data,this.delete_data);
            }
        };

        this._search = function(search) {
            if (this._modSettings.mode) {
                if (search.value === '') {
                    for (let node of this.CONTENT_DOM.childNodes) {
                        node.style.display = 'flex';
                    }
                    return;
                }
                for (let id in this.select) {
                    if (!this.select.hasOwnProperty(id)) continue;
                    let text = this.select[id];
                    let line = this.id_line_hash[id];
                    if (text.indexOf(search.value) !== -1 || search.value.indexOf(text) !== -1) {
                        this.CONTENT_DOM.childNodes[line].style.display = 'flex';
                    } else {
                        this.CONTENT_DOM.childNodes[line].style.display = 'none';
                    }
                }
                return;
            }
            if (search.value === '') {
                if (this.SELECT_COVER_DOM instanceof HTMLElement) {
                    let elements = [];
                    this.SELECT_COVER_DOM.childNodes.forEach((D) => {
                        elements.push(D);
                    });
                    this.CONTENT_DOM.append(...elements);
                    this.SELECT_COVER_DOM.remove();
                    this.SELECT_COVER_DOM = null;
                }
                return;
            }
            if (!(this.SELECT_COVER_DOM instanceof HTMLElement)) {
                this.SELECT_COVER_DOM = document.createElement('div');
                this.SELECT_COVER_DOM.className = 'dot-select dlp-scroll dot-select-cover';
                this.CONTENT_DOM.parentNode.appendChild(this.SELECT_COVER_DOM);
            } else {
                let elements = [];
                this.SELECT_COVER_DOM.childNodes.forEach((D) => {
                    elements.push(D);
                });
                this.CONTENT_DOM.append(...elements);
            }
            let elements = [];
            for (let element of this.CONTENT_DOM.childNodes) {
                if (element.className.indexOf('dlp-label') === -1) {
                    continue;
                }
                if (element.innerText.indexOf(search.value) !== -1 || search.value.indexOf(element.innerText) !== -1) {
                    elements.push(element);
                }
            }
            this.SELECT_COVER_DOM.append(...elements);
        };

        this._menuSelect = function(select) {
            if (this.limit === 1) {
                this.SELECTED_DOM.innerHTML = `<p class="dlp-text">${select[this.select_data[0]]}</p>`;
                return;
            }
            let html = '';
            for (let id of this.select_data) {
                html += `<span class="dlp-text" title="${select[id]}">${select[id]}</span>`;
            }
            this.SELECTED_DOM.innerHTML = html;
        };

        this._bind = function(){
            setTimeout(() => {
                let queue = [];
                this.CONTENT_DOM.childNodes.forEach((D) => {
                    let id = parseInt(D.getAttribute('data-id'));
                    if (selected.indexOf(id) !== -1) {
                        queue.push(D);
                    }
                });
                queue.forEach((D) => D.click());
                if (this._modSettings.mode === true) this.DOM.querySelector('.menu-list').style.display = 'none';
            });
            if (this._useSearchMod === false) return;
            let search = this.DOM.querySelector(`.dot-search`);
            search.addEventListener('input', () => {
                setTimeout(() => {
                    this._search(search);
                }, 500);
            });
        };
        return this;
    }

    mod(settings= {mode: false, placeholder: '未选择', height: '150px'}){
        this._modSettings = Object.assign({mode: false, placeholder: '未选择', height: '150px',useSearch:true},settings);
        return this;
    }

    useSearch(){
        this._useSearchMod = true;
        return this;
    }

    trigger(f = function () {}){
        this._triggerEvent = f;
        return this;
    }

    make() {
        let selected = this.selected_data;
        let select = this.select;
        if(this._modSettings.mode === true){
            let menu = document.createElement('div');
            menu.className = 'dlp-dot-menu';
            let menu_select = document.createElement('div');
            menu_select.className = 'dlp-input dlp-dot-menu-select';
            menu_select.insertAdjacentHTML('afterbegin', `<div class="dlp dlp-text">${this._modSettings.placeholder}</div><div>▼</div>`);
            let menu_list = document.createElement('div');
            menu_list.className = 'menu-list';
            let list = document.createElement('div');
            list.className = 'list dlp-scroll';
            list.style.maxHeight = this._modSettings.height;
            let check = _component.check;
            check = check.replace(`width="16" height="16"`, `width="12" height="12"`);
            this.id_line_hash = [];
            let line = 0;
            for (let id in select) {
                if (!select.hasOwnProperty(id)) continue;
                this.id_line_hash[id] = line;
                line++;
                let option = document.createElement('div');
                option.className = 'option';
                option.setAttribute('data-id', id);
                option.insertAdjacentHTML('afterbegin', `<div class="dlp dlp-text" data-v="${id}">${select[id]}</div><div></div>`);
                option.addEventListener('click', () => {
                    id = parseInt(id);
                    if (this.select_data.indexOf(id) !== -1) {
                        /*cancel*/
                        this._tagCal(id, this.MODE.delete);
                        option.classList.remove('option-active');
                        if (option.lastChild instanceof HTMLElement) option.lastChild.innerHTML = '';
                        this._menuSelect(select);
                        if (this.select_data.length === 0) this.SELECTED_DOM.textContent = this._modSettings.placeholder;
                        return;
                    }
                    if (this.limit > 0 && this.select_data.length >= this.limit) {
                        list.childNodes[this.id_line_hash[this.select_data[0].toString()]].click();
                    }
                    option.classList.add('option-active');
                    this._tagCal(id, this.MODE.insert);
                    (option.lastChild instanceof HTMLElement) && option.lastChild.insertAdjacentHTML('afterbegin', check);
                    this._menuSelect(select);
                }, false);
                list.append(option);
            }

            menu.append(menu_select);
            if(this._useSearchMod === true) {
                let search_box = document.createElement('div');
                search_box.className = 'search-box';
                let input = document.createElement('input');
                input.className = 'dlp dlp-input dot-search';
                input.setAttribute('placeholder', '搜索');
                search_box.append(input);
                menu_list.append(search_box);
            }
            menu_list.append(list);
            menu.append(menu_list);
            menu.addEventListener('click', () => {
                menu_list.style.display = 'flex';
            });
            menu.addEventListener('mouseleave', () => {
                menu_list.style.display = 'none';
                if(this._useSearchMod === true) this.DOM.querySelector(`.dot-search`).value = '';
                for (let node of this.CONTENT_DOM.childNodes) {
                    node.style.display = 'flex';
                }
            });

            this.DOM.append(menu);
            this.DOM.insertAdjacentHTML('beforeend', `<input name="${this.name}[select]" value='${JSON.stringify(selected)}' type="hidden"><input name="${this.name}[insert]" value="[]" type="hidden"><input name="${this.name}[delete]" value="[]" type="hidden">`);
            this.SELECTED_DOM = document.querySelector(`#${this.name}  .dlp-dot-menu-select`).firstElementChild;
            this.CONTENT_DOM = document.querySelector(`#${this.name}  .list`);
            this.selectInputDOM = document.querySelector(`input[name='${this.name}[select]']`);
            this.insertInputDOM = document.querySelector(`input[name='${this.name}[insert]']`);
            this.deleteInputDOM = document.querySelector(`input[name='${this.name}[delete]']`);

            this._bind();
            return
        }
        let select_dom = '';
        for (let i in select) {
            if (!select.hasOwnProperty(i)) continue;
            select_dom += `<div class="dlp dlp-label dlp-text" data-id="${i}" title="${select[i]}"><span>${select[i]}</span></div>`;
        }
        let search = '';
        if (this._useSearchMod){
            search = '<input type="text" class="dlp dot-search" placeholder="搜索名称">';
        }
        let html = `<div class="dlp dlp-dot" ><div class="dot-top">${search}<div class="dot-selected dlp-scroll"></div></div><div class="dot-body"><div class="dot-select dlp-scroll">${select_dom}</div></div></div>
<input name="${this.name}[select]" value='${JSON.stringify(selected)}' type="hidden"><input name="${this.name}[insert]" value="[]" type="hidden"><input name="${this.name}[delete]" value="[]" type="hidden">`;
        this.DOM.insertAdjacentHTML('afterbegin', html);
        this.SELECTED_DOM = document.querySelector(`#${this.name}  .dot-selected`);
        this.CONTENT_DOM = document.querySelector(`#${this.name}  .dot-select`);
        this.selectInputDOM = document.querySelector(`input[name='${this.name}[select]']`);
        this.insertInputDOM = document.querySelector(`input[name='${this.name}[insert]']`);
        this.deleteInputDOM = document.querySelector(`input[name='${this.name}[delete]']`);
        for (let element of this.CONTENT_DOM.getElementsByClassName("dlp-label")) {
            element.addEventListener('click', ()=>this._tagSelect(element), false);
        }
        this._bind();
    }
};

window.ComponentCascadeDot = class {
    MODE = {
        insert: 'insert',
        delete: 'delete'
    };

    constructor(name, select, selected, limit = 0) {
        if (!Array.isArray(selected)) {
            console.error('CascadeDot param selected must be array!');
            return;
        }
        if (!Array.isArray(select) || (typeof select[0] !== 'object' || Array.isArray(select[0]))) {
            console.error('CascadeDot param select must be object such as [{"key":1,"val":"北京","nodes":[]},...] !');
            return;
        }

        this.name = name;
        this.limit = limit;
        this.DOM = document.getElementById(name);
        this.select = select;
        this.selected_data = selected;
        this.select_data = [];
        this.insert_data = [];
        this.delete_data = [];

        this._makeSelect = function(select) {
            this.dimensional_data = [];
            this.selected_label_dom = [];
            _component.dimensional(this.dimensional_data, select);
            let object = this;
            for (let stack in this.dimensional_data) {
                if (!this.dimensional_data.hasOwnProperty(stack)) continue;
                stack = parseInt(stack);
                let data = this.dimensional_data[stack];
                let stackDom = document.createElement('div');
                stackDom.className = 'dot-cascade-stack dlp-scroll';
                data.forEach((v, k) => {
                    if (Array.isArray(v.nodes) && v.nodes.length !== 0) {
                        v.nodes = v.nodes.map((N) => N.key);
                    } else {
                        v.nodes = null;
                        v.checked = false;
                    }
                    let div = document.createElement('div');
                    div.className = 'dlp dlp-text dlp-label';
                    div.insertAdjacentHTML('afterbegin', `<i class="left"></i><span>${v.val}</span><i class="right"></i>`);
                    div.setAttribute('data-id', v.key);
                    div.setAttribute('data-k', k);
                    div.addEventListener('click', this._select.bind(this, div, stack));
                    if (v.nodes !== null) {
                        div.querySelector('i.left').insertAdjacentHTML('afterbegin', `${_component.caret_right}`);
                        div.addEventListener("contextmenu", (e) => {
                            if (e.target instanceof HTMLElement) e.target.click();
                            e.preventDefault();
                            let k = parseInt(div.getAttribute('data-k'));
                            _component.contextmenu(e, [
                                {
                                    title: '全选', func: () => {
                                        object._checkAll(stack + 1,
                                            this.dimensional_data[stack][k].nodes, true);
                                        if (e.target instanceof HTMLElement) e.target.click();
                                    }
                                },
                                {
                                    title: '取消', func: () => {
                                        object._checkAll(stack + 1,
                                            this.dimensional_data[stack][k].nodes, false);
                                    }
                                }
                            ]);
                        });
                    } else {
                        div.addEventListener("contextmenu", (e) => {
                            e.preventDefault();
                        });
                    }
                    stackDom.append(div);
                    /*selected append*/
                    let index = this.selected_data.indexOf(parseInt(v.key));
                    if (v.checked !== false && index !== -1) {
                        this.selected_data.splice(index, 1);
                        return;
                    }
                    if (index !== -1) {
                        this.selected_label_dom.push(div);
                    }
                });
                this.CONTENT_DOM.append(stackDom);
            }
            this.STACKS = this.CONTENT_DOM.childNodes;
        };

        this._select = function(element, stack) {
            let id = parseInt(element.getAttribute('data-id'));
            let k = parseInt(element.getAttribute('data-k'));
            let data = this.dimensional_data[stack][k];
            let currentStackDocuments = this.STACKS[stack].childNodes;
            let parentNode = data.parentNodes[data.parentNodes.length - 1];
            if (data.checked === true) {
                data.checked = false;
                this._tagCal(id, this.MODE.delete);
                if (data.nodes === null) element.querySelector('i.right').innerHTML = '';
                for (let D of this.SELECTED_DOM.childNodes) {
                    if (parseInt(D.getAttribute('data-id')) === id) {
                        D.remove();
                        break;
                    }
                }
            } else {
                this.dimensional_data[stack].forEach((data, index) => {
                    if (data.parentNodes.indexOf(parentNode) !== -1) {
                        currentStackDocuments[index].classList.remove('dlp-label-silence');
                    } else {
                        currentStackDocuments[index].classList.add('dlp-label-silence');
                    }
                });
                if (data.checked === false) {
                    if (this.limit > 0 && this.select_data.length >= this.limit && (this.SELECTED_DOM.firstChild instanceof HTMLElement)) {
                        this.SELECTED_DOM.firstChild.click();
                    }
                    data.checked = true;
                    this._tagCal(id, this.MODE.insert);
                    element.classList.remove('dlp-label-silence');
                    element.querySelector('i.right').insertAdjacentHTML('afterbegin', _component.check);
                    this._selectToChildren(stack + 1, data.nodes);
                    this._selectToSelected(element, stack);
                    this.SELECTED_DOM.scrollTop = this.SELECTED_DOM.scrollHeight;
                } else {
                    element.classList.remove('dlp-label-silence');
                    this._selectToChildren(stack + 1, data.nodes);
                }
            }
            if (Array.isArray(data.parentNodes) && data.parentNodes.length > 0) {
                let parentNodes = data.parentNodes.slice(0);
                this._selectToParent(parentNodes, data.checked);
            }
        };

        this._selectToSelected = function(element, stack) {
            let div = document.createElement('div');
            div.className = 'dlp dlp-text dlp-label';
            div.setAttribute('data-id', element.getAttribute('data-id'));
            div.setAttribute('stack', stack);
            div.insertAdjacentHTML('afterbegin', `<span>${element.querySelector('span').textContent}</span>`);
            div.addEventListener('click', () => {
                this._select(element, stack);
            });
            this.SELECTED_DOM.append(div);
        };

        this._selectToParent = function(nodes, checked) {
            let stack = nodes.length - 1;
            let node = nodes.pop();
            let parentNode = nodes[stack - 1];
            let currentStackDocuments = this.STACKS[stack].childNodes;
            let to_first_index = null;
            this.dimensional_data[stack].forEach((data, index) => {
                let D = currentStackDocuments[index];
                let parents = data.parentNodes;
                if (checked === true || checked === undefined) {
                    if (parents.length > 0 && (parents[stack - 1] !== parentNode)) {
                        D.classList.add('dlp-label-silence');
                    } else if (parents.length === 0 && parseInt(D.getAttribute('data-id')) !== node) {
                        D.classList.add('dlp-label-silence');
                    } else {
                        D.classList.remove('dlp-label-silence');
                        if (parseInt(D.getAttribute('data-id')) === node) {
                            if (to_first_index === null) to_first_index = index;
                        } else {
                        }
                    }
                }
                if (checked === true && node === data.key && data.mark !== true) {
                    data.mark = true;
                    D.querySelector('.right').insertAdjacentHTML('afterbegin', _component.check_circle);
                }
                if (checked === false && node === data.key) {
                    let nodes = this.dimensional_data[stack][index].nodes;
                    let cancel = true;
                    for (let d of this.dimensional_data[stack + 1]) {
                        if (nodes.indexOf(d.key) !== -1 && (d.checked === true || d.mark === true)) {
                            cancel = false;
                            break;
                        }
                    }
                    if (cancel) {
                        data.mark = false;
                        D.querySelector('i.right').innerHTML = '';
                    }
                }
            });
            if (to_first_index !== null) this.STACKS[stack].scrollTo(0, to_first_index * 27);
            if (nodes.length > 0) {
                this._selectToParent(nodes, checked);
            }
        };

        this._selectToChildren = function(stack, nodes) {
            if (stack > (this.dimensional_data.length - 1)) return;
            let currentStackDocuments = this.STACKS[stack].childNodes;
            let children = [];
            let to_first_index = null;
            this.dimensional_data[stack].forEach((data, index) => {
                let D = currentStackDocuments[index];
                if (nodes === null) {
                    D.classList.add('dlp-label-silence');
                    return;
                }
                if (nodes.indexOf(parseInt(D.getAttribute('data-id'))) !== -1) {
                    D.classList.remove('dlp-label-silence');
                    let child = data.nodes;
                    if (Array.isArray(child)) {
                        child.forEach((c) => {
                            if (children.indexOf(child) === -1) children.push(c);
                        });
                    }
                    if (to_first_index === null) to_first_index = index;
                } else {
                    D.classList.add('dlp-label-silence');
                }
            });
            if (to_first_index !== null) this.STACKS[stack].scrollTo(0, to_first_index * 27);
            this._selectToChildren(stack + 1, children);
        };

        this._tagCal = function(id, operate) {
            if (operate === this.MODE.insert) {
                if (this.select_data.indexOf(id) === -1) {
                    this.select_data.push(id);
                    this.selectInputDOM.value = JSON.stringify(this.select_data);
                }
                if (this.selected_data.indexOf(id) === -1 && this.insert_data.indexOf(id) === -1) {
                    this.insert_data.push(id);
                    this.insertInputDOM.value = JSON.stringify(this.insert_data);
                }
                let index = this.delete_data.indexOf(id);
                if (index !== -1) {
                    this.delete_data.splice(index, 1);
                    this.deleteInputDOM.value = JSON.stringify(this.delete_data);
                }
            } else if (operate === this.MODE.delete) {
                let index = this.select_data.indexOf(id);
                if (index !== -1) {
                    this.select_data.splice(index, 1);
                    this.selectInputDOM.value = JSON.stringify(this.select_data);
                }
                if (this.selected_data.indexOf(id) !== -1 && this.delete_data.indexOf(id) === -1) {
                    this.delete_data.push(id);
                    this.deleteInputDOM.value = JSON.stringify(this.delete_data);
                }
                index = this.insert_data.indexOf(id);
                if (index !== -1) {
                    this.insert_data.splice(index, 1);
                    this.insertInputDOM.value = JSON.stringify(this.insert_data);
                }
            }
            if (typeof this._triggerEvent == 'function'){
                this._triggerEvent(this.select_data,this.insert_data,this.delete_data);
            }
        };

        this._search = function(search) {
            if (search.value === '') {
                if (this.SELECT_COVER_DOM instanceof HTMLElement) {
                    this.SELECT_COVER_DOM.remove();
                    this.SELECT_COVER_DOM = null;
                    this.COVER_STACK_HASH_DOM = [];
                }
                return;
            } else if (!(this.SELECT_COVER_DOM instanceof HTMLElement)) {
                this.COVER_STACK_HASH_DOM = [];
                this.SELECT_COVER_DOM = document.createElement('div');
                this.SELECT_COVER_DOM.className = 'dot-select-cover dlp-scroll dot-select-cascade';
                for (let stack = 1; stack <= this.dimensional_data.length; stack++) {
                    let div = document.createElement('div');
                    div.className = 'dot-cascade-stack dlp-scroll';
                    this.SELECT_COVER_DOM.append(div);
                }
                this.CONTENT_DOM.parentNode.append(this.SELECT_COVER_DOM);
            }
            this.dimensional_data.forEach((data, stack) => {
                this._searchPushTag(search, data, stack);
            });
        };

        this._searchCoverClick = function(stack, data, dom) {
            if (data.nodes !== null) {
                let nextStack = stack + 1;
                Array.isArray(this.dimensional_data[nextStack]) &&
                this._searchPushTag(data.nodes, this.dimensional_data[nextStack], nextStack);
                return;
            }
            (dom instanceof HTMLElement) && dom.click();
        };

        this._searchPushTag = function(search, data, stack) {
            data.forEach((d, k) => {
                if (Array.isArray(search)) {
                    if (search.indexOf(d.key) === -1) return;
                } else {
                    if (d.val.indexOf(search.value) === -1 && search.value.indexOf(d.val) === -1) return;
                }
                if (Array.isArray(this.COVER_STACK_HASH_DOM[stack]) && this.COVER_STACK_HASH_DOM[stack].indexOf(d.key) !== -1) return;
                let div = document.createElement('div');
                div.className = 'dlp dlp-text dlp-label';
                div.insertAdjacentHTML('afterbegin', `<i class="left"></i><span>${d.val}</span><i class="right"></i>`);
                if (d.nodes !== null) div.querySelector('i.left').insertAdjacentHTML('afterbegin', _component.caret_right);
                div.addEventListener('click', () => this._searchCoverClick(stack, d, this.STACKS[stack].childNodes[k]));
                this.SELECT_COVER_DOM.childNodes[stack].prepend(div);
                if (!Array.isArray(this.COVER_STACK_HASH_DOM[stack])) {
                    this.COVER_STACK_HASH_DOM[stack] = [d.key];
                    return;
                }
                this.COVER_STACK_HASH_DOM[stack].push(d.key);
            });
        };

        this._checkAll = function(stack, nodes, check) {
            if (stack > (this.dimensional_data.length - 1)) return;
            if (!Array.isArray(nodes) || nodes.length <= 0) return;
            let currentStackDocuments = this.STACKS[stack].childNodes;
            let children = [];
            let to_first_index = null;
            currentStackDocuments.forEach((D, index) => {
                if (nodes.indexOf(parseInt(D.getAttribute('data-id'))) !== -1) {
                    let checked = this.dimensional_data[stack][index].checked;
                    if (check === true) {
                        checked === false && D.click();
                    } else if (check === false) {
                        checked === true && D.click();
                    }
                    let child = this.dimensional_data[stack][index].nodes;
                    if (Array.isArray(child)) {
                        child.forEach((c) => {
                            if (children.indexOf(child) === -1) children.push(c);
                        });
                    }
                    if (to_first_index === null) to_first_index = index;
                }
            });
            if (to_first_index !== null) this.STACKS[stack].scrollTo(0, to_first_index * 27);
            this._checkAll(stack + 1, children, check);
        };

        this._bind = function () {
            setTimeout(() => {
                this.selected_label_dom.forEach((D) => {
                    D.click();
                });
            });
            this.selectInputDOM.value = JSON.stringify(this.select_data);
            if(this._useSearchMod === true) {
                let search = document.querySelector(`#${this.name} .dot-search`);
                search.addEventListener('input', () => {
                    setTimeout(() => {
                        this._search(search);
                    }, 500);
                });
            }
        }
    }

    useSearch(){
        this._useSearchMod = true;
        return this;
    }

    trigger(f = function () {}){
        this._triggerEvent = f;
        return this;
    }

    make() {
        let search = '';
        if(this._useSearchMod === true) search = '<input type="text" class="dlp dot-search" placeholder="搜索名称">';
        let html = `<div class="dlp dlp-dot"><div class="dot-top">${search}<div id="${this.name}-select" class="dot-selected dlp-scroll"></div></div><div class="dot-body"><div class="dot-select dot-select-cascade"></div></div></div><input name="${this.name}[select]" value="[]" type="hidden"><input name="${this.name}[insert]" value="[]" type="hidden"><input name="${this.name}[delete]" value="[]" type="hidden">`;
        this.DOM.insertAdjacentHTML('afterbegin', html);
        this.DOM.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });
        this.SELECTED_DOM = document.querySelector(`#${this.name} .dot-selected`);
        this.CONTENT_DOM = document.querySelector(`#${this.name} .dot-select`);
        this.selectInputDOM = document.querySelector(`input[name='${this.name}[select]']`);
        this.insertInputDOM = document.querySelector(`input[name='${this.name}[insert]']`);
        this.deleteInputDOM = document.querySelector(`input[name='${this.name}[delete]']`);
        this._makeSelect(this.select);
        this._bind();
    }
};

window.ComponentLine = class {
    constructor(name, columns, data, options = {}) {
        this.DOM = document.getElementById(name);
        this.NAME = name;
        this.DOM.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });
        this.flatpickr_settings = {};
        this.COLUMNS = columns;
        this.DATA = data;
        this.OPTIONS = Object.assign({
            sortable: true,
            delete: true,
            insert: true
        }, options);
        /*head foot*/
        let foot = this.makeHeadFoot();
        /*hidden data container*/
        this.DATA_INPUT = document.createElement('input');
        this.DATA_INPUT.setAttribute('name', name);
        this.DATA_INPUT.setAttribute('type', 'hidden');
        this.DATA_INPUT.value = '[]';
        this.DOM.appendChild(this.DATA_INPUT);
        /*tbody list*/
        this.makeBody();
        /*foot*/
        this.makeFoot(foot);
        /*sort*/
        if (this.OPTIONS.sortable) this.sortable();
    }

    makeHeadFoot() {
        let head = '<tr class="dlp-tr">';
        let foot = document.createElement('tr');
        foot.className = 'dlp-tr';
        let columns = this.COLUMNS;
        this.INSERT_ROW_MENUE_DATA = {};
        for (let column in columns) {
            if (!columns.hasOwnProperty(column)) continue;
            let val = columns[column];
            if (val.type === 'hidden') {
                continue;
            }
            let style = val.style ? `style="${val.style}"` : '';
            head += `<th class="dlp-text text-white" ${style}>${val.name}</th>`;
            let insert_type = val.insert_type ? val.insert_type : val.type;

            switch (insert_type) {
                case 'input':
                    foot.insertAdjacentHTML('beforeend', `<th ${style}><input class="dlp dlp-input" data-column="${column}" placeholder=":${val.name}"/></th>`);
                    break;
                case 'select':
                    let td = document.createElement('td');
                    td.style = val.style;
                    td.append(this.menuMake(column, [], val.options, val.options_limit, val.name, true));
                    foot.append(td);
                    break;
                case 'datetime':
                    this.flatpickr_settings[column] = val.config;
                    style = val.style ? `${val.style}` : '';
                    foot.insertAdjacentHTML('beforeend', `<th style="position: relative;overflow: unset;${style}"><input class="dlp dlp-input datetime-${column}" data-column="${column}"/></th>`);
                    break;
                case 'hidden':
                    foot.insertAdjacentHTML('beforeend', `<th><input data-column="${column}" type="hidden"/></th>`);
                    break;
                default:
                    this.COLUMNS[column].insert_type = 'input';
                    foot.insertAdjacentHTML('beforeend', `<th ${style}><input class="dlp dlp-input" data-column="${column}" placeholder=":${val.name}"/></th>`);
                    break;
            }
            /*delay image loading*/
            if(val.type === 'image'){
                setTimeout(()=>{
                    let zoom = val.zoom !== undefined ? val.zoom : true;
                    let width = val.w !== undefined ? parseInt(val.w) : 300;
                    let height = val.h !== undefined ? parseInt(val.h) : 0;
                   _component.imgDelay(`${this.NAME}-${column}-img`,200,zoom,width,height);
                });
            }
            if(val.type === 'datetime' || val.insert_type === 'datetime'){
                setTimeout(() => {
                    document.querySelectorAll(`#${this.NAME} input.datetime-${column}`).flatpickr(this.flatpickr_settings[column]);
                });
            }
        }
        head += '<th class="operate-column" style="width: 48px;"></th></tr>';
        foot.insertAdjacentHTML('beforeend', '<th class="insert_handel operate-column" style="width: 48px;"><div></div></th></tr>');

        this.DOM.insertAdjacentHTML('afterbegin', `<table class="dlp dlp-table" style="height: 100%"><thead class="dlp-thead">${head}</thead></table>`);
        this.TABLE_DOM = this.DOM.getElementsByTagName('table')[0];
        return foot;
    }

    makeBody() {
        let records = [];
        let tbody = document.createElement('tbody');
        let columns = this.COLUMNS;
        if (Array.isArray(this.DATA) === false) return;
        this.DATA.forEach((values, key) => {
            let tr = document.createElement('tr');
            tr.className = 'dlp-tr';
            tr.setAttribute('sortable-item', 'sortable-item');
            let record = {};
            for (let name in columns) {
                if (!columns.hasOwnProperty(name)) continue;
                let column = columns[name];
                if (!values[name]) {
                    this.DATA[key][name] = '';
                    record[name] = '';
                }
                let td = document.createElement('td');
                let v = this.DATA[key][name];
                if (column.type === 'select') {
                    if (/^[0-9]+$/.test(v)) {
                        v = [parseInt(v)];
                    } else if (Array.isArray(v) === false) {
                        v = [];
                    }
                }
                this.makeTd(td, name, column, v);
                record[name] = v;
                tr.appendChild(td);
            }
            let td = document.createElement('td');
            td.insertAdjacentHTML('afterbegin', '<div></div>');
            this.operateButton(td);
            tr.appendChild(td);
            tbody.appendChild(tr);
            records.push(record);
        });
        this.DATA = records;
        this.DATA_INPUT.value = JSON.stringify(records);
        tbody.setAttribute('sortable-list', 'sortable-list');
        tbody.className = 'dlp-tbody dlp-scroll';
        this.TBODY_DOM = tbody;
        this.TABLE_DOM.appendChild(tbody);
    }

    makeFoot(foot) {
        let tfoot = document.createElement('tfoot');
        tfoot.className = 'dlp-tfoot';
        if (!this.OPTIONS.insert) {
            tfoot.insertAdjacentHTML('afterbegin', `<tr class="dlp-tr"></tr>`);
            this.TABLE_DOM.appendChild(tfoot);
            return;
        }
        tfoot.append(foot);
        this.TABLE_DOM.appendChild(tfoot);
        /*insert action*/
        let i = document.createElement('i');
        i.className = 'dlp text-white';
        i.style.cursor = 'pointer';
        i.insertAdjacentHTML('afterbegin', _component.write);
        i.addEventListener('click', () => {
            let tfoot = this.DOM.getElementsByTagName('tfoot')[0];
            let insert = {};
            let tr = document.createElement('tr');
            tr.className = 'dlp-tr';
            tr.setAttribute('sortable-item', 'sortable-item');

            for (let column in this.COLUMNS) {
                if (!this.COLUMNS.hasOwnProperty(column)) continue;
                let type = this.COLUMNS[column].insert_type ? this.COLUMNS[column].insert_type : this.COLUMNS[column].type;
                let td = document.createElement('td');
                let value;
                if (type === 'input' || type === 'datetime') {
                    value = tfoot.querySelector(`input[data-column="${column}"]`).value;
                } else if (type === 'select') {
                    value = this.INSERT_ROW_MENUE_DATA[column];
                } else {
                    value = '';
                }
                insert[column] = value;
                this.makeTd(td, column, this.COLUMNS[column], value);
                tr.appendChild(td);

                if(this.COLUMNS[column].type === 'image'){
                    let dom = td.firstChild;
                    setTimeout(()=>{
                        let src = dom.getAttribute('data-src');
                        dom.setAttribute('src',src);
                        if(this.COLUMNS[column].zoom === false)return;
                        let img = document.createElement('img');
                        dom.addEventListener('mouseover', function(e) {
                            document.body.append(img);
                            img.style.position = 'absolute';
                            img.style.top = `${e.pageY + 7}px`;
                            img.style.left = `${e.pageX + 7}px`;
                            img.style.zIndex = '1000000';
                            img.style.width = '300px';
                            img.style.borderRadius = '3px';
                            img.setAttribute('src', src);
                        });
                        dom.addEventListener('mouseout', function(e) {
                            e.stopPropagation();
                            img.remove();
                        });
                    },200);
                }
            }

            let td = document.createElement('td');
            td.insertAdjacentHTML('afterbegin', '<div></div>');
            this.operateButton(td);
            tr.appendChild(td);
            this.TBODY_DOM.appendChild(tr);
            this.DATA.push(insert);
            this.DATA_INPUT.value = JSON.stringify(this.DATA);
            this.TBODY_DOM.scrollTop = this.TBODY_DOM.scrollHeight;
        }, false);
        this.TABLE_DOM.querySelector('.insert_handel div').appendChild(i);
    }

    makeTd(td, column, settings, value) {
        let input;
        let DATA = this.DATA;
        let DATA_INPUT = this.DATA_INPUT;
        switch (settings.type) {
            case 'text':
                td.insertAdjacentHTML('afterbegin', `<p style="display: block;" class="dlp text-white dlp-text" title="${value}">${value}</p>`);
                break;
            case 'input':
                input = document.createElement('input');
                input.className = 'dlp dlp-input';
                input.setAttribute('data-column', column);
                input.value = value;
                input.addEventListener('input', () => {
                    let key = this.searchChildrenDomIndex(input.parentNode.parentNode);
                    let column = input.getAttribute('data-column');
                    if (DATA[key]) {
                        DATA[key][column] = input.value;
                        DATA_INPUT.value = JSON.stringify(DATA);
                    }
                }, false);
                td.appendChild(input);
                break;
            case 'datetime':
                input = document.createElement('input');
                input.setAttribute('class', `dlp dlp-input datetime-${column}`);
                input.setAttribute('data-column', column);
                input.value = value;

                input.addEventListener('blur', () => {
                    let key = this.searchChildrenDomIndex(input.parentNode.parentNode);
                    let column = input.getAttribute('data-column');
                    if (DATA[key]) {
                        DATA[key][column] = input.value;
                        DATA_INPUT.value = JSON.stringify(DATA);
                    }
                }, false);
                td.appendChild(input);
                td.style.position = 'relative';
                setTimeout(()=>{
                    input.flatpickr(settings.config);
                });
                break;
            case 'select':
                td.append(this.menuMake(column, value, settings.options, settings.options_limit, settings.name));
                break;
            case 'image':
                td.insertAdjacentHTML('afterbegin',`<img class="${this.NAME}-${column}-img" style="max-width: 100%;max-height: 100%;border-radius: 2px" data-src="${value}" />`);
                break;
            default:
                td.insertAdjacentHTML('afterbegin', `<p style="display: block;" class="dlp text-white dlp-text" title="${value}">${value}</p>`);
                break;
        }
        if (settings.style) {
            td.style = settings.style;
        }
    }

    operateButton(td) {
        if (this.OPTIONS.sortable) {
            let M = document.createElement('i');
            M.className = 'dlp text-white';
            M.setAttribute('style', 'cursor: pointer;');
            M.setAttribute('sortable-handle', 'sortable-handle');
            M.insertAdjacentHTML('afterbegin', _component.move);
            td.firstElementChild.appendChild(M);
        }

        if (this.OPTIONS.delete) {
            let D = document.createElement('i');
            D.className = 'dlp text-white';
            D.setAttribute('style', 'cursor: pointer;');
            D.insertAdjacentHTML('afterbegin', _component.trash);
            D.addEventListener('click', () => {
                let tr = D.parentNode.parentNode.parentNode;
                let tbody = tr.parentNode;
                let key = this.searchChildrenDomIndex(tr);

                this.DATA.splice(key, 1);
                tbody.removeChild(tr);
                this.DATA_INPUT.value = JSON.stringify(this.DATA);
            }, false);
            td.firstElementChild.appendChild(D);
        }
        td.className = 'operate-column';
    }

    menuMake(column, selected, select, limit, placeholder, insertRow = false) {
        let menu = document.createElement('div');
        menu.className = 'dlp-dot-menu';
        if (insertRow) this.INSERT_ROW_MENUE_DATA[column] = [];

        let menu_select = document.createElement('div');
        menu_select.className = 'dlp-input dlp-dot-menu-select';
        menu_select.insertAdjacentHTML('afterbegin', `<div class="dlp dlp-text">${placeholder}</div><div>▼</div>`);

        let menu_list = document.createElement('div');
        menu_list.className = 'menu-list';
        let search_box = document.createElement('div');
        search_box.className = 'search-box';
        let input = document.createElement('input');
        input.className = 'dlp dlp-input dot-search';
        input.setAttribute('placeholder', '搜索');
        input.addEventListener('input', () => {
            setTimeout(() => {
                if (input.value === '') {
                    for (let node of list.childNodes) {
                        node.style.display = 'flex';
                    }
                    return;
                }
                for (let node of list.childNodes) {
                    let text = node.firstElementChild.innerText;
                    if (text.indexOf(input.value) !== -1 || input.value.indexOf(text) !== -1) {
                        node.style.display = 'flex';
                    } else {
                        node.style.display = 'none';
                    }
                }
            }, 300);
        });

        let list = document.createElement('div');
        list.className = 'list dlp-scroll';

        let check = _component.check;
        check = check.replace(`width="16" height="16"`, `width="12" height="12"`);
        for (let id in select) {
            if (!select.hasOwnProperty(id)) continue;
            let option = document.createElement('div');
            option.className = 'option';
            option.setAttribute('data-id', id);
            option.insertAdjacentHTML('afterbegin', `<div class="dlp dlp-text" data-v="${id}">${select[id]}</div><div></div>`);
            option.addEventListener('click', () => {
                id = parseInt(id);
                let selected;
                if (insertRow) {
                    selected = this.INSERT_ROW_MENUE_DATA[column];
                } else {
                    let key = this.searchChildrenDomIndex(menu.parentNode.parentNode);
                    selected = this.DATA[key][column];
                }
                let index = selected.indexOf(id);
                if (index !== -1) {
                    /*cancel*/
                    selected.splice(index, 1);
                    option.classList.remove('option-active');
                    if (option.lastChild instanceof HTMLElement) option.lastChild.innerHTML = '';
                    menuSelect(select, selected, limit);
                    if (selected.length === 0) menu_select.firstElementChild.textContent = placeholder;
                    if (insertRow === false) {
                        this.DATA_INPUT.value = JSON.stringify(this.DATA);
                    }
                    return;
                }
                if (limit > 0 && selected.length >= limit) {
                    for (let line of list.childNodes) {
                        if ((selected.hasOwnProperty('0')) && line.getAttribute('data-id') === selected[0].toString()) line.click();
                    }
                }
                option.classList.add('option-active');
                selected.push(id);
                (option.lastChild instanceof HTMLElement) && option.lastChild.insertAdjacentHTML('afterbegin', check);
                menuSelect(select, selected, limit);
                if (insertRow === false) this.DATA_INPUT.value = JSON.stringify(this.DATA);
            }, false);
            /*init selected*/
            if (limit > 0 && selected.length >= limit) selected.slice(0, limit);
            if (selected.indexOf(parseInt(id)) !== -1) {
                option.classList.add('option-active');
                (option.lastChild instanceof HTMLElement) && option.lastChild.insertAdjacentHTML('afterbegin', check);
                menuSelect(select, selected, limit);
            }
            list.append(option);
        }

        function menuSelect(select, selected, limit) {
            if (limit === 1) {
                menu_select.firstElementChild.innerHTML = `<p class="dlp-text">${select[selected[0]]}</p>`;
                return;
            }
            let html = '';
            for (let id of selected) {
                html += `<span class="dlp-text" title="${select[id]}">${select[id]}</span>`;
            }
            menu_select.firstElementChild.innerHTML = html;
        }

        menu.append(menu_select);
        search_box.append(input);
        menu_list.append(search_box);
        menu_list.append(list);
        menu.append(menu_list);
        menu.addEventListener('click', () => {
            menu_list.style.display = 'flex';
        });
        menu.addEventListener('mouseleave', () => {
            menu_list.style.display = 'none';
            let search = this.DOM.querySelector(`.dot-search`);
            search.value = '';
        });

        return menu;
    }

    sortable() {
        let object = this;
        new ComponentSortable(this.TBODY_DOM, function (sort) {
            let data = [];
            sort.forEach(function (k) {
                data.push(object.DATA[k]);
            });
            object.DATA = data;
            object.DATA_INPUT.value = JSON.stringify(object.DATA);
        });
    }

    searchChildrenDomIndex(dom) {
        let i = 0;
        while ((dom = dom.previousSibling) != null) i++;
        return i;
    }
};

window.ComponentPlane = class {
    WIDTH;
    HEIGHT;
    FULLSCREEN;
    constructor(url, xhr = {}, options = {}) {
        if(document.querySelector('#dlp-plane') instanceof HTMLElement)return;
        this.URL = url;
        this.XHR = Object.assign({
            url: url,
            method: 'POST',
            listener: null,
            event: 'click',
            callback: null,
        }, xhr);
        this.OPTIONS = Object.assign({
            w: 0.8,
            h: 0.8,
            top: '30px',
            left: 'auto'
        }, options);
        this.FULLSCREEN = false;
        this.makeModal();
        this.makeContent();
    }

    makeModal() {
        let width = this.OPTIONS.w;
        if (this.OPTIONS.w.toString().indexOf('px') === -1 && this.OPTIONS.w.toString().indexOf('%') === -1) {
            width = window.innerWidth * this.OPTIONS.w;
            if(width>= (window.innerWidth - 18)) width = window.innerWidth - 18;
            width += 'px';
        }
        let height = this.OPTIONS.h;
        if (this.OPTIONS.h.toString().indexOf('px') === -1 && this.OPTIONS.h.toString().indexOf('%') === -1) {
            height = window.innerHeight * this.OPTIONS.h;
            if(height>= (window.innerHeight - 25)) height = window.innerHeight - 25;
            height += 'px';
        }
        this.WIDTH = width;
        this.HEIGHT = height;
        let margin = this.OPTIONS.top + ' ' + this.OPTIONS.left;
        let html = `<div id="dlp-plane" class="dlp-plane-gauze"><div style="width: ${width};margin: ${margin}"><div class="dlp plane-header"></div><div class="plane-body dlp-scroll" style="height:${height};"></div></div></div>`;
        document.body.insertAdjacentHTML('beforeEnd', html);
        this.DOM = document.getElementById('dlp-plane');
        /*F*/
        let F = document.createElement('i');
        F.style.marginRight = '10px';
        F.insertAdjacentHTML('afterbegin', _component.aspect);
        F.addEventListener('click', () => {
            if (this.FULLSCREEN === false){
                this.FULLSCREEN = true;
                this.DOM.firstChild.style.width = '100%';
                this.DOM.firstChild.style.margin = '0';
                this.DOM.querySelector('.plane-body').style.height = (window.innerHeight - 25)+'px';
            }else {
                this.FULLSCREEN = false;
                this.DOM.firstChild.style.width = this.WIDTH;
                this.DOM.firstChild.style.marginTop = this.OPTIONS.top;
                if(this.OPTIONS.left === 'auto'){
                    this.DOM.firstChild.style.margin = `${this.OPTIONS.top} auto`;
                }else {
                    this.DOM.firstChild.style.marginTop = this.OPTIONS.top;
                    this.DOM.firstChild.style.marginLeft = this.OPTIONS.left;
                }
                this.DOM.querySelector('.plane-body').style.height = this.HEIGHT;
            }
        }, false);
        this.DOM.querySelector('.plane-header').append(F);
        /*X*/
        let X = document.createElement('i');
        X.insertAdjacentHTML('afterbegin', _component.close);
        X.style.marginRight = '5px';
        X.addEventListener('click', () => {
            if (this.DOM instanceof HTMLElement) {
                this.DOM.remove();
            }
            if (document.getElementById('kvFileinputModal') instanceof HTMLElement) {
                document.getElementById('kvFileinputModal').remove();
            }
        }, false);
        this.DOM.querySelector('.plane-header').append(X);
        this.MODEL_BODY_DOM = this.DOM.querySelector('.plane-body');
        window.addEventListener("popstate", () =>{
            this.DOM.remove();
        }, false);
    }

    makeContent() {
        _component.loading(this.MODEL_BODY_DOM);
        let object = this;
        _component.request({
            url: this.URL,
            method: 'GET',
            callback: function (response) {
                _component.loading(object.MODEL_BODY_DOM, true);
                let fragment = document.createRange().createContextualFragment(response);
                object.MODEL_BODY_DOM.appendChild(fragment);
                let listener = object.XHR.listener;
                if (typeof listener === 'function') {
                    let target = listener(object.MODEL_BODY_DOM);
                    if (target instanceof HTMLElement) {
                        target.addEventListener(object.XHR.event,
                            object.submitEvent.bind(object, target), false);
                    }
                }
            }
        });
    }

    submitEvent(element) {
        let form = this.MODEL_BODY_DOM.getElementsByTagName('form')[0];
        let formdata = new FormData(form);
        let flag = false;
        for (let pair of formdata.entries()) {
            let key = pair[0];
            let val = pair[1];
            let input = form.querySelector(`input[name=${key}]`);
            if(input.hasAttribute('required') && input.value === ''){
                flag = true;
                input.focus();
            }
            if (/\[.*\]/.test(key) && /^\[.*\]$/.test(val) && (typeof val === 'string')) {
                val = JSON.parse(val);
                if (Array.isArray(val) && val.length > 0) {
                    val.forEach((v) => {
                        formdata.append(`${key}[]`, v);
                    });
                } else {
                    formdata.append(`${key}`, '');
                }
            }
        }
        if(flag)return;
        element.setAttribute('disabled', 'disabled');
        element.innerText = '提交中...';
        _component.request({
            url: this.XHR.url,
            method: this.XHR.method,
            data: formdata,
            callback: (response) => {
                if (typeof this.XHR.callback == 'function') {
                    this.XHR.callback(response);
                    return;
                }
                if (!response) return;
                if (response.code === 0) {
                    window.location.reload();
                } else {
                    _component.alert(response.message, 3, function () {
                        element.removeAttribute('disabled');
                        element.innerText = '提交';
                    });
                }
            }
        });
    }
};

window.ComponentSortable = class {
    constructor(list, callback = null) {
        this.list = (typeof list === 'string') ? document.querySelector(list) : list;
        this.options = {
            animationSpeed: 200,
            animationEasing: 'ease-out'
        };
        this.callback = callback;
        this.animation = false;
        this.dragStart = this.dragStart.bind(this);
        this.dragMove = this.dragMove.bind(this);
        this.dragEnd = this.dragEnd.bind(this);
        this.list.addEventListener('touchstart', this.dragStart, false);
        this.list.addEventListener('mousedown', this.dragStart, false);
    }

    reset() {
        this.items = Array.from(this.list.children);
        if (this.items[this.items.length - 1].offsetTop > this.list.offsetHeight) {
            this.listHeight = this.list.scrollHeight;
        } else {
            this.listHeight = this.items[this.items.length - 1].offsetTop;
        }
    }

    dragStart(e) {
        this.reset();
        if (this.animation) return;
        if (this.items.length < 2) return;
        this.handle = null;

        let el = e.target;
        while (el) {
            if (el.hasAttribute('sortable-handle')) this.handle = el;
            if (el.hasAttribute('sortable-item')) this.item = el;
            if (el.hasAttribute('sortable-list')) break;
            el = el.parentElement;
        }

        if (!this.handle) return;
        this.list.style.position = 'relative';
        this.item.classList.add('is-dragging');
        this.itemHeight = this.items[1].offsetTop;
        this.startTouchY = this.getDragY(e);
        this.startTop = this.item.offsetTop;

        const offsetsTop = this.items.map(item => item.offsetTop);

        this.items.forEach((item, index) => {
            item.style.position = 'absolute';
            item.style.top = '0';
            item.style.left = '0';
            item.style.transform = `translateY(${offsetsTop[index]}px)`;
            item.style.zIndex = (item === this.item) ? '2' : '1';
        });

        this.positions = this.items.map((item, index) => index);
        this.position = Math.round((this.startTop / this.listHeight) * this.items.length);

        this.touch = e.type === 'touchstart';
        window.addEventListener((this.touch ? 'touchmove' : 'mousemove'), this.dragMove);
        window.addEventListener((this.touch ? 'touchend' : 'mouseup'), this.dragEnd, false);
    }

    dragMove(e) {
        if (this.animation) return;
        if (this.items.length < 2) return;
        const top = this.startTop + this.getDragY(e) - this.startTouchY;
        const newPosition = Math.round((top / this.listHeight) * this.items.length);

        this.item.style.transform = `translateY(${top}px)`;

        this.positions.forEach(index => {
            if (index === this.position || index !== newPosition) return;
            this.swapElements(this.positions, this.position, index);
            this.position = index;
        });
        this.items.forEach((item, index) => {
            if (item === this.item) return;
            item.style.transform = `translateY(${this.positions.indexOf(index) * this.itemHeight}px)`;
            item.style.transition = `transform ${this.options.animationSpeed}ms ${this.options.animationEasing}`;
        });
        e.preventDefault();
    }

    dragEnd() {
        this.animation = true;
        if (this.items.length < 2) return;
        this.item.style.transition = `all ${this.options.animationSpeed}ms ${this.options.animationEasing}`;
        this.item.style.transform = `translateY(${this.position * this.itemHeight}px)`;
        this.item.classList.remove('is-dragging');
        if (typeof this.callback == 'function') this.callback(this.positions);

        setTimeout(() => {
            this.list.style.position = '';

            this.items.forEach(item => {
                item.style.top = '';
                item.style.left = '';
                item.style.right = '';
                item.style.position = '';
                item.style.transform = '';
                item.style.transition = '';
                item.style.zIndex = '';
            });

            this.positions.map(i => {
                if (this.items[i]) {
                    this.list.appendChild(this.items[i]);
                }
            });
            this.animation = false;
        }, this.options.animationSpeed);

        window.removeEventListener((this.touch ? 'touchmove' : 'mousemove'), this.dragMove);
        window.removeEventListener((this.touch ? 'touchend' : 'mouseup'), this.dragEnd, false);
    }

    swapElements(array, a, b) {
        let temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }

    getDragY(e) {
        return e.touches ? (e.touches[0] || e.changedTouches[0]).pageY : e.pageY;
    }
};

window.ComponentCascadeLine = class {
    constructor(name, select, url, options) {
        if (!Array.isArray(select)) {
            console.error('CascadeLine param select must be array!');
            return;
        }
        this.name = name;
        this.OPTIONS = Object.assign({
            movable: true,
            exchange: true,
            detail: true,
            insert: true,
            update: true,
            delete: true,
            root: true
        }, options);
        this.DOM = document.getElementById(name);
        this.URL = url;
        this.make().makeSelect(select);
        if (this.OPTIONS.insert) this.makeHeader();

        let search = document.querySelector(`#${this.name} .dot-search`);
        search.addEventListener('input', () => {
            setTimeout(() => {
                this.search(search);
            }, 700);
        });

        if (!this.OPTIONS.movable) return;
        for (let D of this.DOM.querySelectorAll('i.right')) {
            this.nodeMigrate(D);
        }
    }

    make() {
        let html = `<div class="dlp dlp-dot dlp-cascadeLine"><div class="dot-top"><div class="search-box"><input type="text" class="dlp dot-search" placeholder="搜索名称"></div></div><div class="dot-body"><div class="dot-select dot-select-cascade" drag-area="true"></div></div></div>`;
        this.DOM.insertAdjacentHTML('afterbegin', html);
        this.DOM.addEventListener("contextmenu", (e) => {
            e.preventDefault();
        });
        this.HEADER_DOM = document.querySelector(`#${this.name} .dot-top`);
        this.CONTENT_DOM = document.querySelector(`#${this.name} .dot-select`);
        this.SEARCH_BOX = document.querySelector(`#${this.name} .search-box`);
        return this;
    }

    makeHeader() {
        let I = document.createElement('div');
        I.className = 'dlp-btn';
        I.addEventListener('click', (() => {
            this.panel('新增根节点');
            let object = this;
            _component.request({
                url: this.URL + '/create',
                method: 'GET',
                data: {},
                callback: function (response) {
                    object.panelContent(response, {key: 0}, object.URL, 'POST', (response) => {
                        if (response.data.key === undefined) return _component.alert('返回数据结构缺少key', 3, null, object.DOM);
                        if (response.data.val === undefined) return _component.alert('返回数据结构缺少val', 3, null, object.DOM);
                        let key = parseInt(response.data.key);
                        let val = response.data.val;
                        let len = object.dimensional_data[0].push({
                            expand: false,
                            key: key,
                            val: val,
                            nodes: null,
                            parentNodes: []
                        });
                        let lastKey = len - 1;
                        let currentStackDocuments = object.STACKS[0];
                        currentStackDocuments.append(object.insertLabelDom(object.dimensional_data[0][lastKey], lastKey, 0));
                        object.STACKS[0].scrollTo(0, lastKey * 27);
                        currentStackDocuments.lastChild.click();
                        object.PLANE_DOM.remove();
                    });
                }
            });
        }));
        I.insertAdjacentHTML('afterbegin', _component.node);
        this.HEADER_DOM.append(I);
    }

    makeSelect(select) {
        this.dimensional_data = [];
        _component.dimensional(this.dimensional_data, select);
        for (let stack in this.dimensional_data) {
            if (!this.dimensional_data.hasOwnProperty(stack)) continue;
            stack = parseInt(stack);
            let data = this.dimensional_data[stack];
            let stackDom = document.createElement('div');
            stackDom.className = 'dot-cascade-stack dlp-scroll';
            data.forEach((v, k) => {
                v.stack = stack;
                if (Array.isArray(v.nodes) && v.nodes.length !== 0) {
                    v.nodes = v.nodes.map((N) => N.key);
                    v.expand = false;
                } else {
                    v.nodes = null;
                }
                let labelDom = this.insertLabelDom(v, k, stack);
                if (v.nodes !== null) {
                    labelDom.insertAdjacentHTML('afterbegin', `<i class="left">${_component.caret_right}</i>`);
                }
                stackDom.append(labelDom);
            });
            this.CONTENT_DOM.append(stackDom);
        }
        this.STACKS = this.CONTENT_DOM.childNodes;
    }

    insertLabelDom(data, index, stack) {
        let div = document.createElement('div');
        div.className = 'dlp dlp-text dlp-label';
        div.insertAdjacentHTML('afterbegin', `<span>${data.val}</span>`);
        div.setAttribute('data-id', data.key.toString());
        div.setAttribute('data-k', index.toString());
        div.setAttribute('data-stack', stack.toString());
        div.setAttribute('drag-zone', 'true');
        div.addEventListener('click', this.select.bind(this, div, stack));
        div.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            if (e.target instanceof HTMLElement) e.target.click();
            let settings = [];
            if (this.OPTIONS.detail) settings.push({
                title: '详情', func: () => {
                    this.nodeDetail(div, data);
                }
            });
            if (this.OPTIONS.insert) settings.push({
                title: '新增', func: () => {
                    this.nodeInsert(div, data, stack);
                }
            });
            if (this.OPTIONS.update) settings.push({
                title: '修改', func: () => {
                    this.nodeUpdate(div, data);
                }
            });
            if (this.OPTIONS.delete) settings.push({
                title: '删除', func: () => {
                    this.nodeDelete(div, data, stack);
                }
            });
            if (this.OPTIONS.root) settings.push({
                title: _component.node, func: () => {
                    let stack = parseInt(div.getAttribute('data-stack'));
                    let index = parseInt(div.getAttribute('data-k'));
                    let node_data = this.dimensional_data[stack][index];
                    this.dialog(`<span class="dlp-text title" title="${node_data.val}">${node_data.val}</span> 迁移到根节点`, 90);
                    let M = document.createElement('div');
                    M.className = 'dlp dlp-text dlp-label';
                    M.insertAdjacentHTML('afterbegin', `<span>${node_data.val}</span><i class="right">${_component.check_circle}</i>`);
                    this.PLANE_BODY.insertAdjacentHTML('afterbegin', `<div class="dlp" style="display: flex">${_component.node}</div>`);
                    this.PLANE_BODY.insertAdjacentHTML('beforeend', `<div style="font-size: 16px!important;">↑</div>`);
                    let object = this;
                    M.addEventListener('click', (() => {
                        if (node_data.stack === 0) return object.PLANE_DOM.remove();
                        if (object.submit_block) return;
                        object.submit_block = true;
                        M.querySelector('.right').innerHTML = _component.sub_loading;
                        _component.request({
                            url: this.URL,
                            method: 'GET',
                            data: {event: 'root', node_key: node_data.key, node_val: node_data.val},
                            callback: function (response) {
                                object.submit_block = false;
                                response = JSON.parse(response);
                                if (response.code !== 0) return _component.alert(response.message, 3, null, object.DOM);
                                object.nodeRootExec(div, node_data);
                                object.PLANE_DOM.remove();
                            }, error_callback: function () {
                                object.submit_block = false;
                            }
                        });
                    }));
                    this.PLANE_BODY.append(M);
                }
            });
            _component.contextmenu(e, settings);
        });
        if (this.OPTIONS.movable) div.insertAdjacentHTML('beforeend', `<i class="right">${_component.move}</i>`);
        return div;
    }

    select(element, stack) {
        let k = parseInt(element.getAttribute('data-k'));
        let data = this.dimensional_data[stack][k];
        let currentStackDocuments = this.STACKS[stack].childNodes;
        let parentNode = data.parentNodes[data.parentNodes.length - 1];

        this.dimensional_data[stack].forEach((data, index) => {
            let D = currentStackDocuments[index];
            if (data.parentNodes.indexOf(parentNode) !== -1) {
                D.classList.remove('dlp-label-silence');
            } else {
                D.classList.add('dlp-label-silence');
            }
            this.expand(data, currentStackDocuments[index], false);
        });
        this.expand(data, element, true);
        element.classList.remove('dlp-label-silence');
        this.selectToChildren(stack + 1, data.nodes);
        if (Array.isArray(data.parentNodes) && data.parentNodes.length > 0) {
            let parentNodes = data.parentNodes.slice(0);
            this.selectToParent(parentNodes);
        }
    }

    selectToParent(nodes) {
        let stack = nodes.length - 1;
        let node = nodes.pop();
        let parentNode = nodes[stack - 1];
        let currentStackDocuments = this.STACKS[stack].childNodes;
        let to_first_index = null;
        this.dimensional_data[stack].forEach((data, index) => {
            let D = currentStackDocuments[index];
            let parents = data.parentNodes;
            if (parents.length > 0 && (parents[stack - 1] !== parentNode)) {
                D.classList.add('dlp-label-silence');
                this.expand(data, D, false);
            } else if (parents.length === 0 && parseInt(D.getAttribute('data-id')) !== node) {
                D.classList.add('dlp-label-silence');
                this.expand(data, D, false);
            } else {
                D.classList.remove('dlp-label-silence');
                if (parseInt(D.getAttribute('data-id')) === node) {
                    if (to_first_index === null) to_first_index = index;
                    this.expand(data, D, true);
                } else {
                    this.expand(data, D, false);
                }
            }
        });
        if (to_first_index !== null) this.STACKS[stack].scrollTo(0, to_first_index * 27);
        if (nodes.length > 0) {
            this.selectToParent(nodes);
        }
    }

    selectToChildren(stack, nodes) {
        if (stack > (this.dimensional_data.length - 1)) return;
        let currentStackDocuments = this.STACKS[stack].childNodes;
        let children = [];
        let to_first_index = null;
        this.dimensional_data[stack].forEach((data, index) => {
            let D = currentStackDocuments[index];
            if (nodes === null) {
                D.classList.add('dlp-label-silence');
                return;
            }
            if (nodes.indexOf(parseInt(D.getAttribute('data-id'))) !== -1) {
                D.classList.remove('dlp-label-silence');
                let child = this.dimensional_data[stack][index].nodes;
                if (Array.isArray(child)) {
                    child.forEach((c) => {
                        if (children.indexOf(child) === -1) children.push(c);
                    });
                }
                if (to_first_index === null) to_first_index = index;
                this.expand(data, D, true);
            } else {
                D.classList.add('dlp-label-silence');
                this.expand(data, D, false);
            }
        });
        if (to_first_index !== null) this.STACKS[stack].scrollTo(0, to_first_index * 27);
        this.selectToChildren(stack + 1, children);
    }

    expand(data, dom, open = true) {
        if (data.expand === open) return;
        data.expand = open;
        let left_mark = dom.querySelector('i.left');
        if (!(left_mark instanceof HTMLElement)) return;
        if (open) {
            left_mark.innerHTML = _component.caret_right_circle;
            return;
        }
        left_mark.innerHTML = _component.caret_right;
    }

    panel(title) {
        let html = `<div class="dot-cascade-panel"><div class="dlp plane-header"></div><div class="plane-body dlp-scroll"></div></div>`;
        this.DOM.childNodes[0].insertAdjacentHTML('beforeend', html);
        let panelDom = this.DOM.childNodes[0].lastChild;
        let header = panelDom.querySelector('.plane-header');
        this.PLANE_DOM = panelDom;
        let T = document.createElement('div');
        T.className = 'header-content';
        T.insertAdjacentHTML('afterbegin', _component.node + ` <span style="vertical-align: top;">${title}</span>`);
        header.append(T);
        /*X*/
        let X = document.createElement('i');
        X.insertAdjacentHTML('afterbegin', _component.close);
        X.addEventListener('click', () => {
            panelDom.remove();
        }, false);
        header.append(X);
        this.PLANE_BODY = panelDom.querySelector('.plane-body');
        _component.loading(this.PLANE_BODY);
    }

    panelContent(response, data, xhr, method, callback) {
        _component.loading(this.PLANE_BODY, true);
        let fragment = document.createRange().createContextualFragment(response);
        this.PLANE_BODY.appendChild(fragment);
        let submit = document.createElement('div');
        submit.insertAdjacentHTML('afterbegin', _component.check);
        submit.addEventListener('click', this.submitEvent.bind(this, submit, data, xhr, method, callback));
        submit.className = 'dlp-submit-btn';
        if (!(this.PLANE_DOM instanceof HTMLElement)) return;
        let header = this.PLANE_DOM.querySelector('.plane-header');
        let X = header.querySelector('i');
        header.insertBefore(submit, X);
    }

    submitEvent(element, data, xhr, method, callback) {
        if (this.submit_block) return;
        this.submit_block = true;
        element.innerHTML = _component.sub_loading;
        let form = this.DOM.getElementsByTagName('form')[0];
        let formdata = new FormData(form);
        formdata.set('key', data.key);
        formdata.set('val', data.val);
        formdata.set('_method', method);
        let object = this;
        _component.request({
            url: xhr,
            method: 'POST',
            data: formdata,
            callback: function (response) {
                object.submit_block = false;
                element.innerHTML = _component.check;
                if (response.code !== 0) {
                    return _component.alert(response.message, 3, null, object.DOM);
                }
                callback(response);
            }, error_callback: function () {
                object.submit_block = false;
            }
        });
    }

    nodeDetail(dom, data) {
        this.panel(`<span class="dlp-text title" title="${data.val}">${data.val}</span> 详情`);
        let object = this;
        _component.request({
            url: this.URL + '/' + data.key,
            method: 'GET',
            data: {},
            callback: function (response) {
                _component.loading(object.PLANE_BODY, true);
                let fragment = document.createRange().createContextualFragment(response);
                object.PLANE_BODY.appendChild(fragment);
            }
        });
    }

    nodeInsert(dom, data, stack) {
        this.panel(`<span class="dlp-text title" title="${data.val}">${data.val}</span> 新增`);
        let object = this;
        let nextStack = parseInt(stack) + 1;
        _component.request({
            url: this.URL + '/create',
            method: 'GET',
            data: {id: data.key},
            callback: function (response) {
                object.panelContent(response, data, object.URL, 'POST', (response) => {
                    if (response.code !== 0) return _component.alert(response.message, 3, null, object.DOM);
                    if (response.data.key === undefined) return _component.alert('返回数据结构缺少key', 3, null, object.DOM);
                    if (response.data.val === undefined) return _component.alert('返回数据结构缺少val', 3, null, object.DOM);
                    let key = parseInt(response.data.key);
                    let val = response.data.val;
                    let parents = data.parentNodes.slice(0);
                    parents.push(data.key);
                    if (!Array.isArray(object.dimensional_data[nextStack])) {
                        object.dimensional_data[nextStack] = [
                            {expand: false, key: key, val: val, nodes: null, parentNodes: parents}];
                        let stackDom = document.createElement('div');
                        stackDom.className = 'dot-cascade-stack dlp-scroll';
                        stackDom.append(object.insertLabelDom(object.dimensional_data[nextStack][0], 0, nextStack));
                        object.CONTENT_DOM.append(stackDom);
                        dom.insertAdjacentHTML('afterbegin', `<i class="left">${_component.caret_right_circle}</i>`);
                    } else if (!Array.isArray(data.nodes) || data.nodes.length === 0) {
                        let len = object.dimensional_data[nextStack].push(
                            {expand: false, key: key, val: val, nodes: null, parentNodes: parents});
                        let index = len - 1;
                        object.STACKS[nextStack].append(
                            object.insertLabelDom(object.dimensional_data[nextStack][index], index, nextStack));
                        dom.insertAdjacentHTML('afterbegin', `<i class="left">${_component.caret_right_circle}</i>`);
                        object.STACKS[nextStack].scrollTo(0, index * 27);
                    } else {
                        let lastKey = data.nodes[data.nodes.length - 1];
                        let currentStackDocuments = object.STACKS[nextStack].childNodes;
                        let newIndex = 0;
                        for (let index in object.dimensional_data[nextStack]) {
                            if (!object.dimensional_data[nextStack].hasOwnProperty(index)) continue;
                            index = parseInt(index);
                            newIndex = index + 1;
                            if (object.dimensional_data[nextStack][index].key === lastKey) {
                                object.dimensional_data[nextStack].splice(newIndex, 0, {
                                    expand: false,
                                    key: key,
                                    val: val,
                                    nodes: null,
                                    parentNodes: parents
                                });
                                let D = currentStackDocuments[index];
                                D.parentNode.insertBefore(
                                    object.insertLabelDom(object.dimensional_data[nextStack][newIndex], newIndex, nextStack), D.nextSibling);
                                break;
                            }
                        }
                        object.dimensional_data[nextStack].forEach((d, index) => {
                            if (index > newIndex) currentStackDocuments[index].setAttribute('data-k', index);
                        });
                        object.STACKS[nextStack].scrollTo(0, newIndex * 27);
                    }
                    if (!Array.isArray(data.nodes)) data.nodes = [];
                    data.nodes.push(key);
                    object.PLANE_DOM.remove();
                });
            }
        });
    }

    nodeUpdate(dom, data) {
        this.panel(`<span class="dlp-text title" title="${data.val}">${data.val}</span> 修改`);
        let object = this;
        _component.request({
            url: this.URL + '/' + data.key + '/edit',
            method: 'GET',
            data: {val: data.val},
            callback: function (response) {
                object.panelContent(response, data, object.URL + '/' + data.key, 'PUT', (response) => {
                    if (response.code !== 0) return _component.alert(response.message, 3, null, object.DOM);
                    if (response.data.val === undefined) return _component.alert('返回数据结构缺少val', 3, null, object.DOM);
                    let val = response.data.val;
                    data.val = val;
                    dom.querySelector('span').textContent = val;
                    object.PLANE_DOM.remove();
                });
            }
        });
    }

    dialog(title, h = 50) {
        let marginTop = (this.DOM.clientHeight - (h + 20)) / 2;
        let html = `<div class="dot-cascade-panel"><div class="dlp plane-header plane-header-dialog" style="margin-top: ${marginTop + 'px'}"></div><div class="plane-body dlp-scroll plane-body-dialog" style="height:${h + 'px'}"></div></div>`;
        this.DOM.childNodes[0].insertAdjacentHTML('beforeend', html);
        let panelDom = this.DOM.childNodes[0].lastChild;
        let header = panelDom.querySelector('.plane-header');
        let T = document.createElement('div');
        T.className = 'header-content';
        T.insertAdjacentHTML('afterbegin', _component.node + `<span style="vertical-align: top;">${title}</span>`);
        header.append(T);
        /*X close panel*/
        let X = document.createElement('i');
        X.insertAdjacentHTML('afterbegin', _component.close);
        X.addEventListener('click', () => {
            panelDom.remove();
        }, false);
        header.append(X);
        this.PLANE_DOM = panelDom;
        this.PLANE_BODY = panelDom.querySelector('.plane-body');
    }

    nodeDelete(dom, data, stack) {
        let object = this;
        let title = `<span class="dlp-text title" title="${data.val}">${data.val}</span> 删除`;
        this.dialog(title);
        /*D delete node*/
        let D = document.createElement('div');
        D.className = 'dlp dlp-text dlp-label';
        D.addEventListener('click', (() => {
            if (object.submit_block) return;
            object.submit_block = true;
            D.querySelector('.right').innerHTML = _component.sub_loading;
            _component.request({
                url: this.URL + '/' + data.key,
                method: 'DELETE',
                data: {},
                callback: function (response) {
                    object.submit_block = false;
                    if (response.code !== 0) return _component.alert(response.message, 3, null, object.DOM);
                    object.nodeDeleteExec(data, stack);
                    object.PLANE_DOM.remove();
                }, function() {
                    object.submit_block = false;
                }
            });
        }));
        D.insertAdjacentHTML('afterbegin', `<span>${data.val}</span><i class="right">${_component.trash}</i>`);
        this.PLANE_BODY.append(D);
    }

    nodeDeleteExec(data, stack) {
        /*parent data delete*/
        let parent_stack = data.parentNodes.length - 1;
        if (parent_stack >= 0) {
            let parent = data.parentNodes.pop();
            for (let i in this.dimensional_data[parent_stack]) {
                if (!this.dimensional_data[parent_stack].hasOwnProperty(i)) continue;
                i = parseInt(i);
                let d = this.dimensional_data[parent_stack][i];
                if (d.key !== parent) continue;
                d.nodes.forEach((node, k) => {
                    if (node === data.key) d.nodes.splice(k, 1);
                });
                if (d.nodes.length === 0) {
                    let left_mark = this.STACKS[parent_stack].childNodes[i].querySelector('i.left');
                    if (left_mark) left_mark.remove();
                }
            }
        }
        /*children data dom delete*/
        for (let currentStack = stack + 1; currentStack < this.dimensional_data.length; currentStack++) {
            let tmp = [];
            let batchDeleteDom = [];
            let resetIndex = 0;
            for (let index in this.dimensional_data[currentStack]) {
                if (!this.dimensional_data[currentStack].hasOwnProperty(index)) continue;
                index = parseInt(index);
                let d = this.dimensional_data[currentStack][index];
                if (d.parentNodes.indexOf(data.key) !== -1) {
                    batchDeleteDom.push(this.STACKS[currentStack].childNodes[index]);
                    continue;
                }
                this.STACKS[currentStack].childNodes[index].setAttribute('data-k', resetIndex);
                resetIndex++;
                tmp.push(d);
            }
            for (let dom of batchDeleteDom) dom.remove();
            if (tmp.length === 0) {
                this.dimensional_data.splice(currentStack, 1);
                this.STACKS[currentStack].remove();
                break;
            }
            this.dimensional_data[currentStack] = tmp;
        }
        /*current dom data delete*/
        let deleteDom;
        let reset = false;
        let resetIndex = 0;
        for (let D of this.STACKS[stack].childNodes) {
            if (parseInt(D.getAttribute('data-id')) === data.key) {
                reset = true;
                this.dimensional_data[stack].splice(resetIndex, 1);
                deleteDom = D;
                continue;
            }
            reset && D.setAttribute('data-k', resetIndex);
            resetIndex++;
        }
        deleteDom.remove();
        if (this.STACKS[stack].childNodes.length === 0) {
            if (stack > 0) {
                this.STACKS[stack].remove();
                this.dimensional_data.splice(stack, 1);
            } else {
                this.dimensional_data = [[]];
            }
        }
    }

    search(search) {
        if (Array.isArray(this.search_result) && this.search_result.length > 0) {
            this.lastPickRemove();
        }
        this.search_result = [];
        if (this.search_result_panel instanceof HTMLElement) this.search_result_panel.remove();
        if (search.value === '') return;
        this.dimensional_data.forEach((data, stack) => {
            data.forEach((d, index) => {
                if (d.val.indexOf(search.value) !== -1 || search.value.indexOf(d.val) !== -1) this.search_result.push({
                    'stack': stack,
                    'index': index
                });
            });
        });
        if (this.search_result.length === 0) return;
        let panel = document.createElement('div');
        panel.className = 'dot-search-result-panel';
        let previous = document.createElement('span');
        previous.className = 'dlp-btn';
        previous.textContent = '◀';
        previous.addEventListener('click', this.searchPick.bind(this, false));
        let next = document.createElement('span');
        next.className = 'dlp-btn';
        next.textContent = '▶';
        next.addEventListener('click', this.searchPick.bind(this, true));
        let pick = document.createElement('span');
        pick.className = 'search-result-number dlp-text';
        pick.textContent = '1';
        this.SEARCH_PICK = pick;
        this.search_result_pick = 1;
        panel.append(previous);
        panel.append(pick);
        panel.insertAdjacentHTML('beforeend', `<span> / </span><span class="search-result-number dlp-text">${this.search_result.length.toString()}</span>`);
        panel.append(next);
        this.search_result_panel = panel;
        this.SEARCH_BOX.append(panel);
        this.pickUp();
    }

    searchPick(toward = true) {
        this.lastPickRemove();
        if (toward) {
            this.search_result_pick++;
            if (this.search_result_pick > this.search_result.length) {
                this.search_result_pick = 1;
            }
        } else {
            this.search_result_pick--;
            if (this.search_result_pick < 1) {
                this.search_result_pick = this.search_result.length;
            }
        }
        this.SEARCH_PICK.textContent = this.search_result_pick.toString();
        this.pickUp();
    }

    lastPickRemove() {
        let pick = this.search_result[(this.search_result_pick - 1)];
        this.STACKS[pick.stack].childNodes[pick.index].classList.remove('dlp-label-active');
    }

    pickUp() {
        let pick = this.search_result[(this.search_result_pick - 1)];
        let DOM = this.STACKS[pick.stack].childNodes[pick.index];
        if (!(DOM instanceof HTMLElement)) return;
        DOM.classList.add('dlp-label-active');
        this.STACKS[pick.stack].scrollTo(0, pick.index * 27);
        DOM.click();
    }

    nodeMigrate(dom) {
        let D = dom.parentNode;
        let object = this;
        let aim = null;

        function f(e) {
            e.preventDefault();
            let el = e.target;
            while (true) {
                if (el === null) break;
                if (el === D) break;
                if (!(el instanceof HTMLElement) && !(el.tagName === 'svg')) break;
                if (el.getAttribute('drag-area') === 'true') break;
                if (el.tagName === 'BODY') break;
                if (el.getAttribute('drag-zone') === 'true') {
                    if (e.type === 'dragover') {
                        aim = el;
                        if (aim.classList.contains('dlp-label-silence')) aim.click();
                        if (!object.OPTIONS.exchange) {
                            let stack = parseInt(aim.getAttribute('data-stack'));
                            let index = parseInt(aim.getAttribute('data-k'));
                            let parents = object.dimensional_data[stack][index].parentNodes;
                            if (Array.isArray(parents) && (parents.indexOf(parseInt(D.getAttribute('data-id'))) === -1)) {
                                aim.style.setProperty('background', '#bb8f2c');
                            }
                        } else {
                            aim.style.setProperty('background', '#bb8f2c');
                        }
                    } else if (e.type === 'dragleave' && aim instanceof HTMLElement) {
                        aim.style.removeProperty('background');
                        aim = null;
                    }
                    break;
                }
                el = el.parentNode;
            }
        }

        function fc() {
            D.removeAttribute('draggable');
            D.style.removeProperty('border');
            D.removeEventListener('dragend', fc);
            document.removeEventListener('dragover', f);
            document.removeEventListener('dragleave', f);
            if (aim instanceof HTMLElement) {
                object.nodeMigrateConfirm(D, aim);
            }
        }

        dom.addEventListener('mousedown', () => {
            D.click();
            D.setAttribute('draggable', 'true');
            D.style.setProperty('border', '1px dashed #3c2d2d');
            document.addEventListener('dragover', f);
            document.addEventListener('dragleave', f);
            D.addEventListener('dragend', fc);
        });
        dom.addEventListener('mouseup', () => {
            dom.parentNode.style.removeProperty('border');
            document.removeEventListener('dragover', f);
            document.removeEventListener('dragleave', f);
            D.removeEventListener('dragend', fc);
            if (aim instanceof HTMLElement) {
                aim.style.removeProperty('background');
                aim = null;
            }
        });
    }

    nodeMigrateConfirm(node, aim_node) {
        let event;
        let stack = parseInt(aim_node.getAttribute('data-stack'));
        let index = parseInt(aim_node.getAttribute('data-k'));
        let aim_node_data = this.dimensional_data[stack][index];
        stack = parseInt(node.getAttribute('data-stack'));
        index = parseInt(node.getAttribute('data-k'));
        let node_data = this.dimensional_data[stack][index];
        let title = '迁移';
        if (aim_node_data.parentNodes.indexOf(node_data.key) !== -1) {
            event = 'exchange';
            title = '迁移.交换';
        } else {
            event = 'migrate';
        }
        if (!this.OPTIONS.exchange && event === 'exchange') return;
        aim_node.style.removeProperty('background');
        this.dialog(`<span class="dlp-text title" title="${node_data.val}">${node_data.val}</span> ${title}`, 90);
        let M = document.createElement('div');
        let object = this;
        M.className = 'dlp dlp-text dlp-label';
        M.insertAdjacentHTML('afterbegin', `<span>${node_data.val}</span><i class="right">${_component.check_circle}</i>`);
        this.PLANE_BODY.insertAdjacentHTML('afterbegin', `<div class="dlp dlp-text dlp-label"><span>${aim_node_data.val}</span></div>`);
        if (event === 'exchange') {
            this.PLANE_BODY.insertAdjacentHTML('beforeend', `<div style="font-size: 16px!important;">⇵</div>`);
        } else {
            this.PLANE_BODY.insertAdjacentHTML('beforeend', `<div style="font-size: 16px!important;">↑</div>`);
        }
        M.addEventListener('click', (() => {
            if (object.submit_block) return;
            object.submit_block = true;
            M.querySelector('.right').innerHTML = _component.sub_loading;
            _component.request({
                url: this.URL,
                method: 'GET',
                data: {
                    event: event,
                    node_key: node_data.key,
                    node_val: node_data.val,
                    aim_node_key: aim_node_data.key,
                    aim_node_val: aim_node_data.val
                }, callback: function (response) {
                    object.submit_block = false;
                    response = JSON.parse(response);
                    if (response.code !== 0) return _component.alert(response.message, 3, null, object.DOM);
                    if (event === 'exchange') object.nodeExchangeExec(node, node_data, aim_node, aim_node_data);
                    if (event === 'migrate') object.nodeMigrateExec(node, node_data, aim_node, aim_node_data);
                    object.PLANE_DOM.remove();
                }, error_callback: function () {
                    object.submit_block = false;
                }
            });
        }));
        this.PLANE_BODY.append(M);
    }

    nodeRootExec(node, node_data) {
        let parent = node_data.parentNodes.slice().pop();
        let parent_stack = node_data.stack - 1;
        node_data.parentNodes = [];
        let diffStack = 0 - node_data.stack;
        let index = parseInt(node.getAttribute('data-k'));
        this.dimensional_data[node_data.stack].splice(index, 1);
        this.dimensional_data[0].push(node_data);
        if (node_data.nodes !== null) this.resetChildrenDimensional(node_data, node_data.stack + 1, diffStack);
        node_data.stack = 0;
        this.dimensional_data = this.dimensional_data.filter((d) => {
            if (d.length > 0) return true;
            return false;
        });
        this.CONTENT_DOM.innerHTML = '';
        for (let stack in this.dimensional_data) {
            if (!this.dimensional_data.hasOwnProperty(stack)) continue;
            stack = parseInt(stack);
            let data = this.dimensional_data[stack];
            let stackDom = document.createElement('div');
            stackDom.className = 'dot-cascade-stack dlp-scroll';
            data.forEach((v, k) => {
                if (parseInt(stack) === parent_stack && v.key === parent) {
                    v.nodes.splice(v.nodes.indexOf(node_data.key), 1);
                }
                if (Array.isArray(v.nodes) && v.nodes.length !== 0) {
                    v.expand = false;
                } else {
                    v.nodes = null;
                }
                let labelDom = this.insertLabelDom(v, k, stack);
                if (v.nodes !== null) {
                    labelDom.insertAdjacentHTML('afterbegin', `<i class="left">${_component.caret_right}</i>`);
                }
                stackDom.append(labelDom);
            });
            this.CONTENT_DOM.append(stackDom);
        }
        this.STACKS = this.CONTENT_DOM.childNodes;
        for (let D of this.DOM.querySelectorAll('i.right')) {
            this.nodeMigrate(D);
        }
    }

    nodeMigrateExec(node, node_data, aim_node, aim_node_data) {
        /*parent*/
        let parent_node = node_data.parentNodes.slice().pop();
        let parent_node_stack = node_data.stack - 1;
        let parents = aim_node_data.parentNodes.slice(0);
        parents.push(aim_node_data.key);
        node_data.parentNodes = parents;
        /*last_child_node*/
        let last_child_node;
        if (aim_node_data.nodes !== null) last_child_node = aim_node_data.nodes.slice(0).pop();
        /*stack*/
        let stack = aim_node_data.stack + 1;
        let diffStack = stack - node_data.stack;
        /*delete*/
        let index = parseInt(node.getAttribute('data-k'));
        this.dimensional_data[node_data.stack].splice(index, 1);
        if (!Array.isArray(this.dimensional_data[stack])) this.dimensional_data[stack] = [];
        /*insert*/
        if (!last_child_node) {
            this.dimensional_data[stack].push(node_data);
        } else {
            let index = 0;
            for (let key in this.dimensional_data[aim_node_data.stack + 1]) {
                if (!this.dimensional_data[aim_node_data.stack + 1].hasOwnProperty(key)) continue;
                if (this.dimensional_data[aim_node_data.stack + 1][key].key === last_child_node) {
                    index = key;
                    break;
                }
            }
            index++;
            this.dimensional_data[aim_node_data.stack + 1].splice(index, 0, node_data);
        }

        this.resetChildrenDimensional(node_data, node_data.stack + 1, diffStack);
        this.dimensional_data = this.dimensional_data.filter((d) => {
            if (d.length > 0) return true;
            return false;
        });
        node_data.stack = stack;
        /*aim node*/
        if (!Array.isArray(aim_node_data.nodes)) aim_node_data.nodes = [];
        aim_node_data.nodes.push(node_data.key);

        this.CONTENT_DOM.innerHTML = '';
        for (let stack in this.dimensional_data) {
            if (!this.dimensional_data.hasOwnProperty(stack)) continue;
            stack = parseInt(stack);
            let data = this.dimensional_data[stack];
            let stackDom = document.createElement('div');
            stackDom.className = 'dot-cascade-stack dlp-scroll';
            data.forEach((v, k) => {
                if (parseInt(stack) === parent_node_stack && v.key === parent_node) {
                    v.nodes.splice(v.nodes.indexOf(node_data.key), 1);
                }
                if (Array.isArray(v.nodes) && v.nodes.length !== 0) {
                    v.expand = false;
                } else {
                    v.nodes = null;
                }
                let labelDom = this.insertLabelDom(v, k, stack);
                if (v.nodes !== null) {
                    labelDom.insertAdjacentHTML('afterbegin', `<i class="left">${_component.caret_right}</i>`);
                }
                stackDom.append(labelDom);
            });
            this.CONTENT_DOM.append(stackDom);
        }
        this.STACKS = this.CONTENT_DOM.childNodes;
        for (let D of this.DOM.querySelectorAll('i.right')) {
            this.nodeMigrate(D);
        }
    }

    nodeExchangeExec(node, node_data, aim_node, aim_node_data) {
        /*node*/
        let tmp_key = node_data.key;
        let tmp_val = node_data.val;
        node_data.key = aim_node_data.key;
        node_data.val = aim_node_data.val;
        let index = node_data.nodes.indexOf(aim_node_data.key);
        if (index !== -1) node_data.nodes.splice(index, 1, tmp_key);
        /*node parent*/
        let parentNode = node_data.parentNodes.slice(0).pop();
        if (parentNode !== undefined) {
            for (let index in this.dimensional_data[node_data.stack - 1]) {
                if (!this.dimensional_data[node_data.stack - 1].hasOwnProperty(index)) continue;
                let d = this.dimensional_data[node_data.stack - 1][index];
                if (d.key === parentNode) {
                    d.nodes.splice(d.nodes.indexOf(tmp_key), 1, aim_node_data.key);
                    break;
                }
            }
        }
        /*aim node*/
        aim_node_data.key = tmp_key;
        aim_node_data.val = tmp_val;
        let aimParentNode = aim_node_data.parentNodes.slice(0).pop();
        for (let index in this.dimensional_data[aim_node_data.stack - 1]) {
            if (!this.dimensional_data[aim_node_data.stack - 1].hasOwnProperty(index)) continue;
            let d = this.dimensional_data[aim_node_data.stack - 1][index];
            if (d.key === aimParentNode) {
                d.nodes.splice(d.nodes.indexOf(node_data.key), 1, aim_node_data.key);
                break;
            }
        }
        this.resetChildrenParent(node_data);

        node.querySelector('span').textContent = node_data.val;
        node.setAttribute('data-id', node_data.key);
        aim_node.querySelector('span').textContent = aim_node_data.val;
        aim_node.setAttribute('data-id', aim_node_data.key);
    }

    resetChildrenParent(node) {
        let stack = node.stack;
        let nodes = node.nodes;
        let parents = node.parentNodes.slice(0);
        parents.push(node.key);
        stack++;
        this.dimensional_data[stack].forEach((d) => {
            if (nodes.indexOf(d.key) !== -1) {
                d.parentNodes = parents;
                if (Array.isArray(d.nodes) && d.nodes.length > 0) {
                    this.resetChildrenParent(d);
                }
            }
        });
    }

    resetChildrenDimensional(node, stack, diffStack) {
        let nodes = node.nodes;
        let parents = node.parentNodes.slice(0);
        parents.push(node.key);
        if (!Array.isArray(this.dimensional_data[stack])) return;
        let indexes = [];
        this.dimensional_data[stack].forEach((d, index) => {
            if (Array.isArray(nodes) && nodes.indexOf(d.key) !== -1) {
                indexes.push(index);
                d.parentNodes = parents;
                d.stack = stack + diffStack;
                if (!Array.isArray(this.dimensional_data[d.stack])) this.dimensional_data[d.stack] = [];
                this.dimensional_data[d.stack].push(d);
                this.resetChildrenDimensional(d, stack + 1, diffStack);
            }
        });
        indexes.reverse();
        indexes.forEach((d) => {
            this.dimensional_data[stack].splice(d, 1);
        });
    }
};
